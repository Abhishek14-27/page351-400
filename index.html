<html>
    <head>
        <title>Resource Object data manager 351-400</title>
    </head>
    <body>
        <p style="text-align:right;">351-400</p>
        <p>Every time a field is changed, the associated subscription list of notification
methods is processed, and each method in the list is run. The intent of these
methods is to propagate knowledge of changes both to other objects and to
applications outside RODM that need to be informed about changes. Notification
methods can include logic to selectively notify, such as to notify only when a
            threshold is surpassed.</p>  
        <p>When a change transaction is specified against a field, all notification methods
defined on that field are triggered. These notification methods are triggered
regardless of whether or not a change method is defined on the field and whether
or not the value of the field actually changes. Each notification method is passed a
Change_status parameter by RODM, which informs the method whether or not the
value of the field was changed by the change transaction.</p>
        <p>To avoid triggering notification methods, use functions that do not trigger
methods. These functions do not trigger notification methods: v EKG_LinkNoTrigger
v EKG_UnlinkNoTrigger
v EKG_ChangeSubfield
v EKG_SwapSubfield</p>
        <p>The subscription list on the child is not processed, and the notification methods are
not run. Notification methods are active only when values in fields are locally
present. This practice is similar to the practice of avoiding triggering change
methods where the value in the associated field is inherited, and a change is made
to the parent field.</p>
        <p>Some notification methods can delete themselves after their first execution. For
example, an application submits a RODM transaction that causes a command to be
submitted to the target system where the command is attempting to vary a device
offline. Completion of the request takes time.</p>
        <p>The transaction cannot wait for the response, and the application needs to be
informed when the command is complete. The code, which might be a change
method implementing the original transaction, places a notification method in the
subscription (notification) queue for the field. When the device is varied offline, the
notification method pulls itself out of the subscription queue and notifies the
original application that the requested vary command has been successfully run.</p>
        <p>When a method calls the EKG_AddNotifySubscription function, that method must
acquire the required information, identified by the data type SubscriptSpec, to
actually perform the function. This information is obtained through
long-lived-parameters and short-lived-parameters.</p>
        <p>Notification methods are placed in the subscription list of a field upon an explicit
request made by an application using the EKG_AddNotifySubscription function in
the user API and method API. Notification methods can be deleted from a
subscription list using the EKG_DeleteNotifySubscription function.</p>
       <p>The subscription list for a field is always processed in the order that the
notification methods were placed in the subscription queue. The methods are
processed, one at a time, starting with the first method placed in queue.</p>
        <p>There is another issue of how inheritance interacts with notification methods.
Notification subscriptions are not inherited from a parent class to a child class.
However, they are effectively inherited from a class to an object, where the class isthe primary parent of the object. Notification subscriptions can be associated with
any class or object. When it is associated with a class and that class field changes,
the notification list on that class field is run. When a change is made to an object
field, the notification subscriptions assigned to the field in that object are run. Any
notification subscriptions assigned to the same field in the primary parent are also
run, enabling you to use a single notification subscription at the class level for all
objects in the class. Methods assigned to an object parent class can use the
“WhereAmI” method API to determine the circumstances under which their
execution has been triggered.</p>
        <p>The NetView program supplies four sample notification methods in source format.
Study these methods to learn more about writing your own notification method.
The sample methods are the following members of the CNMSAMP data set: v EKGNEQL
v EKGNLST
v EKGNOTF
v EKGNTHD</p>
        <p>These methods are described in “RODM Notification Methods” on page 489.</p>
        <p>Figure 82 shows an example of notification parameters for PL/I. Figure 83 shows
an example of notification parameters for C.</p>
        <img src="scrsht1.jpg">
        <p><b>Named Methods</b></p>
        <p>A named method is indicated by a field defined as MethodSpec, containing: v Method object ID
v Long-lived method parameters
A named method: v Allows for multiple coordinated actions against an objectv Named method field can also have query, change, notify, prev_val, and time
stamp subfields.</p>
        <p>The named method parameters are:</p>
        <p><b>field_id</b></p>
        <p>FieldID of the field being run.</p>
        <p><b>long_lived_parms</b></p>
        <p>SelfDefining string containing application-defined parameters. These
parameters are provided to the named method when it is installed.</p>
        <p><b>short_lived_parms</b></p>
        <p>SelfDefining string containing application-defined parameters. These
parameters are provided to the method dynamically during the actual API
function request that triggers the named method.</p>
        <p>The method is considered named because it can be referenced (queried, changed
and triggered) using the field name. The field name represents a field in an object
with the data type of MethodSpec. A field of this type contains a method name
and a list of long-lived field parameters that are available to the method when the
method is run. Explicit actions available in the user API and method API are used
to trigger named methods.</p>
        <p>Named methods enable you to change more than one field of a class or object.
RODM locks all of the fields of the target object when a named method is run. No
other method or user application can access those fields until the named method
completes. This enables you to coordinate the updates to several fields on a target
class or object.</p>
        <p>Because many named methods can all be associated with all objects of a class,
named methods are typically inherited from the class. Many standard transactions
against objects can be implemented by either methods that are supplied with the
NetView program or user-written methods.</p>
        <p>A field of data type MethodSpec, a named method field, can have its own query, change, notify, and other standard subfields. The data in the value subfield of such
a field includes the method name and a list of field parameters. The specified field
parameters can be the targets of actions taken by the named method, or they can
contain arguments to the execution of the named method. As with query and
change methods, the long-lived list of field parameters is determined when the
named method field is assigned a value. The contents of any fields referenced
through the long-lived parameters can be set at any time.</p>
        <p>Besides the field parameters, another parameter can be passed at execution time to
a named method by the application that triggers the method. This is called a
short-lived parameter. Unlike long-lived field parameters, it is not preserved in any
way after the named method has run. All short-lived parameters on named
methods must be of data type SelfDefining of maximum length 254. Such
short-lived parameters are a variable length string of bytes that can be structured
in any way that the requesting application and the named method are written to
recognize.</p>
        <p>The NetView program supplies a sample named method in source format. Study
this method to learn more about writing your own named method. The sample
method is the member EKGMIMV of the CNMSAMP data set. This method is
described in “RODM Named Methods” on page 493.</p>
        <p>Figure 84 shows an example of named method parameters for PL/I. Figure 85
shows an example of named method parameters for C.</p>
        <img src="scrsht2.jpg">
        <p>A named method has access to the same data, and has the same abilities as query
and change methods. However, the explicit invocation of named methods is at the
discretion of applications using RODM, and named methods are free form in the
function that they provide if the function can be implemented with the available
data and services.</p>
        <p><b>Inheritance in Object-Specific Methods</b></p>
        <p>Query, change, notify, and named methods are all object-specific methods. Of these
methods, only named methods are values in fields of RODM objects. Query, change, and notify methods are all stored in subfields of objects. On an object, the
named method fields and subfields on fields are inherited from the subfields of the
public classes of that object.</p>
        <p>In the same way, the values in named method fields and the values in query and
change subfields can be inherited through primary inheritance, using the standard
principles for supporting inheritance in RODM. Notify methods are inherited from
the primary parent to its object children. They are not inherited throughout the
class inheritance tree. However, the object fields can additionally have local values
that do not override the class-level notification subscriptions. (So standard
inheritance of values does not apply to notification subfields.)</p>
        <p>Named methods, query methods, change methods and notification methods can
also all exist on classes. Change methods on classes (as on objects) can be used to
validate changes before they are made, or they can be used to validate a user's
authority to make those changes. Query methods can validate a requestor's
authority to see the requested data, or they can validate data before it is returned.</p>
        <p>Likewise, named methods on classes can be used in ways similar to the ways such
methods are used on objects. Complex changes to a class can be run by a named
method, or general-purpose functions, applicable to many individual classes, can
be implemented with named methods. Finally, notification methods are also
valuable on classes.</p>
        <p>Change and notification methods on children that are inheriting values from
parents are not triggered when the inherited values are changed on parents.</p>
        <p>Therefore, notification methods are required on parents (which can be classes) so
that user applications can be notified when parameters and values change on
parents.</p>
        <p>The main purpose of the primary hierarchy of classes is to make it easy to specify
the organization of and default values in RODM objects. The most common values
that are inherited at the object level from the primary hierarchy include:</p>
        <p>Methods and parameters to control the management of RODM data to reflect
real-world objects</p>
        <p>Policy parameters that indicate standard limits and thresholds</p>
        <p>Long-lived characteristics, such as capacity, of RODM objects where those
characteristics are needed to manage real-world objects</p>
        <p>These methods and values appear in fields on classes so they can be stated once
and then inherited by many objects through the primary hierarchy.</p>
        <p>When a value that is a method is inherited by a child, if that method is triggered
and run for a child, execution takes place in the context of the child. While the
method resided on the parent, only its name and its long-lived parameters are
picked up through the inheritance process. When such a method runs and asks for
the contents of a field, it gets the contents of that field on the child entity.</p>
        <p>A query, change, or named method installed on a class can fill two roles. The
method can be the default change method inherited by children and applied in the
context of those children (including children that are objects instead of classes), and
it can be triggered in the standard way (query, change of field, direct invocation) in
the context of the parent.</p>
        <p>Be aware that object-specific method you write can sometimes run on an object
and at other times can run on a class. The same kinds of capabilities are available
for both objects and classes, using the same method API calls. Many object-specific
methods look at the WhatIAm field on the current entity to discover the context in
which the method is executing, and different actions might be appropriate in
different contexts.</p>
        <p>Query, change, named, and notification methods on fields of classes are triggered
as part of transactions against those classes just as those kinds of methods are
triggered on objects. Also, query, change, and named methods exist on fields of
classes to support inheritance of those methods by objects, but inheritance of
values in notification subfields is not supported in RODM.</p>
        <p>If a notification list exists through inheritance, it begins as a null value. A null
value in the notification list field is functionally equivalent to no list at all. Entries
can be added to a notification list by using the EKG_AddNotifySubscription
function.</p>
        <p>In summary, named methods and query, change, and notify subfields all function
in the standard way both on private and on public fields of classes. There is no
inheritance involving private fields, but query, change, and notification methods
are run when the corresponding field is queried or changed. When a field is on a
class (as with fields on objects), a change transaction for the field triggers change
and notification methods, but a change transaction for the value subfield of a field
does not trigger change and notification methods. This function is the same as that
supported for objects.</p><br>
        <p><b>Null Method</b></p>
        <p>RODM provides a special method named NullMeth. You can use the NullMeth
object ID in place of any object specific method. NullMeth returns control to its
caller without doing any processing. The value NullMeth can be inherited in a
field or subfield from a parent class. If the value of a field of type MethodSpec is
queried for a null method, the ObjectID for NullMeth is returned in the response
block.</p>
        <p>Using the NullMeth method name, a query or change subfield that is inherited can
be set to do nothing. The effect is the same as if the local subfield does not exist.
This is useful where the standard function for a field or subfield is to take some
action, but there are a few exceptions where that function is locally overridden to
do nothing.</p>
        <p>Similarly, an empty notification list acts like no list exists. If the corresponding field
changes, no notification methods are triggered, and no one is notified of the event.</p><br>
        <p><b>Deciding Which Method Type to Use</b></p>
        <p>Before you use a method, you must decide which type of method you need to use.
What type of method you use depends on the task you want the method to
perform.</p>
        <p><b>When to Use an Object-Independent Method</b></p>
        <p>You use an object-independent method if you want to efficiently manipulate more
than one entity in the RODM data cache. An object-independent method can
change or query any field in any class or object in the RODM data cache.</p>
        <p><b>When to Use an Object-Specific Method</b></p>
        <p>Object-specific methods are methods that have entities specifically associated with
them. You use an object-specific method if you want to manipulate only one entity
in the RODM data cache. The specific entity that is manipulated is determined at
run time and can be different each time that the method is triggered. To run an
action against another object or class, an object-specific method can use the
EKG_MessageTriggeredAction function. An object-specific method can also trigger
the notification method to inform a user application about an event.</p>
        <p>There are four types of object-specific methods:</p>
        <p>Query method</p>
        <p>Change method</p>
        <p>Notify method</p>
        <p>Named method</p>
        <p>Each of these methods is designed to perform a specific task and can perform that
task only on the entity to which it is associated; it cannot access fields in any other
entity. Additionally, object-specific methods can call only the API functions that are
designed to be callable from these methods. See “Other Services Available to
Object-Specific Methods” on page 368 for a list of API functions that are available
to object-specific methods.</p>
        <p><b>Query Method</b></p>
        <p>This object-specific method is triggered when a field that has a non-null query
subfield is queried in response to an EKG_QueryField API function. The query
method ensures that the data returned to the caller of the EKG_QueryField API
function is correct and current.</p>
        <p>Use this method to refresh data in an entity field that might be outdated or to
enforce policy procedures, validation, or security on the data in the field.</p>
        <p><b>Change Method</b></p>
        <p>This object-specific method is triggered when a field that has a non-null change
subfield is changed in response to an EKG_ChangeField function, an
EKG_ChangeMultipleFields, an EKG_LinkTrigger function, or an
EKG_UnlinkTrigger function. The change method ensures that the functions
change, link, or unlink the fields correctly by enforcing data security, data validity, and even policy requirements.</p>
        <p>Use this method to enforce policy procedures, validation, or security on the data in
an entity field</p>
        <p><b>Notify Method</b></p>
        <p>This object-specific method is triggered when the value in a field that has a
non-null notify subfield is changed. The notify method notifies the applications
that are subscribed to the field that the value of the field has changed.</p>
        <p>Use this method to notify an application program of a change in the field value of
an entity field when that information is essential to the operation of the
application.</p>
        <p><b>Named Method</b></p>
        <p>This object-specific method is triggered explicitly by a call to the
EKG_TriggerNamedMethod API function. A named method has the capability of
performing multiple API functions on all fields within a particular entity. RODM
implicitly locks the entity while the method is running. No other method or
application can query or change any of the fields of the target entity until the
Named method returns control to RODM.</p>
        <p>This method is used to perform multiple API functions on a single entity where it
is critical that no other method or application can query or change the entity's
fields.</p>
        <p><b>Using the Method API</b></p>
        <p>To write methods for RODM, access to RODM data and services is required. The
method API provides a set of entry points to RODM that can be called by
methods.</p>
        <p>A variety of services are available to methods. Some services are available only to
object-independent methods, and some are available only to object-specific
methods.</p>
        <p>Method API calls to RODM pass the following parameters:</p>
        <p>Transaction information block</p>
        <p>Function block</p>
        <p>Response block</p>
        <p>The function block can point to additional parameters, such as an entity access
information block and a field access information block, which identify the target of
the function. The response block is required only for some functions.</p>
        <p>The transaction_info_block, function_block, and response_block have the same
format as the blocks used by the user API. Table 36 on page 358 lists where you
can find more information about these blocks.</p>
        <img src="scrsht3.jpg">
        <p>The CALL statement from the PL/I or C language program transfers control to the
code segment EKGMAPI. The method must be link-edited with the EKGMAPI
module during the link-edit step. Figure 86 shows an example PL/I CALL
statement.</p>
        <img src="scrsht4.jpg">
        <p><b>Register Conventions</b></p>
        <p>The method code must follow this register convention:</p>
        <p><b>Register 1</b></p>
        <p>Points to the first of three consecutive memory locations (a parameter list)
that contains addresses of the transaction_info_block, function_block, and
response_block.</p>
        <p><b>Register 12</b></p>
        <p>Is reserved for RODM runtime environment. This register must be
preserved by the method. For code written in PL/I and C, this register
requirement is consistent with the generated code.</p>
        <p><b>Register 13</b></p>
        <p>Contains the address for the 72-byte save area of the calling program.</p>
        <p><b>Register 14</b></p>
        <p>Contains the return address for the calling program.</p>
        <p><b>Register 15</b></p>
        <p>Contains the entry address for the EKGMAPI module.</p>
        <p><b>Usage Notes</b></p>
        <p>The details of all RODM functions are specified in function blocks. The method
builds a function block and passes it to RODM to request a desired transaction.
The method API functions are described in Chapter 14, “Application Programming
Reference,” on page 371.</p>
        <p>The entity_access_information data, pointed to by the function block, is interpreted
the same way for method API calls from object-independent methods as it is from
user API calls. However, class and object information is ignored if the call is made
from an object-specific method.</p>
        <p>The object-specific change, query, notification, and named methods can only access
fields within the object or class from which the method API call is performed.</p>
        <img src="scrsht5.jpg">
        <p>API Query Function Control Block Example</p>
        <p><b>Method Parameters</b></p>
        <p>Many transactions have optional parameters that are either being passed to or
installed with methods. There are two kinds of method parameters:</p>
        <p>1.Long-lived parameters</p>
        <p>2.Short-lived parameters</p>
        <p><b>Long-Lived Parameters</b></p>
        <p>The long-lived parameters are statically defined parameters. Long-lived parameters
are: </p>
        <p>Valid only for object-specific methods</p>
        <p>A variable length, SelfDefining string of data</p>
        <p>Restricted to 254 bytes</p>
        <p>Internal meaning is user-defined and user-interpreted</p>
        <p>Long-lived parameters are saved in RODM with a method at the time the method
is assigned to a subfield, such as when a notification method is installed by the
EKG_AddNotifySubscription function or when a named, query, or change method
is assigned to a field or subfield.</p>
        <p>These long-lived parameters are not immediately used, but are saved until the
corresponding method is run (by the appropriate triggering mechanism), and they
are made available to that method when the method runs. In this way, general
purpose methods can be written and the parameters that provide the desired
function specified when the method is assigned to a field or subfield.</p>
        <p>Long-lived parameters have the form of a variable length, SelfDefining data string
where the length is a maximum of 254 bytes. The content of the 254 bytes of data
is not specified by RODM; it is determined by specification of that particular
method's interface. The contents of the actual SelfDefining data string cannot be
changed after it is specified during method assignment to a field. However, if that
long-lived parameter contains a reference to a field within an object, the value of
that field can be changed at any time.</p>
        <p><b>Short-Lived Parameters</b></p>
        <p>Short-lived parameters are dynamically defined parameters. Short-lived parameters
have the following characteristics:</p>
        <p>Internal meaning is user-defined and user-interpreted for both object-specific
and object-independent methods when the method is run using an API request.</p>
        <p>They are a variable length, SelfDefining string of data.</p>
        <p>v They are restricted to 254 bytes for object-specific methods.</p>
        <p>They are restricted to 32767 bytes for object-independent methods.</p>
        <p>Short-lived parameters are not prestored. They are supplied through the specific
transaction request API and are made immediately available to methods being
triggered by the transaction. These parameters always have the form of a variable
length SelfDefining data string.</p>
        <p>Short-lived parameters passed to object-independent methods through the User
API can be up to 32767 bytes, but short-lived parameters passed to object-specific
methods are restricted to 254 bytes. The meaning of these strings is not defined or
limited by RODM. RODM sees only a string of bytes. The requesting user
application and the methods being triggered must be written to agree on the
contents of this string of bytes.</p>
        <p><b>Installing and Freeing Methods</b></p>
        <p>Before an object-specific method can be assigned to a field or subfield of an object,
and before an object-independent method can be run, the method must be installed
in RODM. To install a method, create an object of the EKG_Method class.</p>
        <p>To install a named method, follow these steps:</p>
        <p>1. Determine where you want to install the method.
For named methods, you must use a field of type MethodSpec on either a class
or an object.</p>
        <p>2. Create an object of the EKG_Method class.</p>
        <p>Creating this object returns to you the object ID of the newly created object.</p>
        <p>3. Use the EKG_ChangeField, the EKG_ChangeSubfield, or
EKG_ChangeMultipleFields functions to set the value of the MethodSpec field
to the object ID and any long-lived parameters required by your method.</p>
        <p>You can also install methods using the RODM load function. When you create an
object in the EKG_Method class, RODM loads the method into its address space.
Attempting to assign a method name to a field or subfield before the method has
been installed results in an error return code from the change transaction.</p>
        <p>If an installed method needs to be changed, the EKG_Refresh field in the
EKG_Method class enables you to load a new copy of the method into RODM.
Trigger the named method specified in the EKG_Refresh field of the method object
you want to reload to load the new copy of the method from the library.</p>
        <p>When a method is no longer needed, a user can free the storage taken up by the
method and can purge the method's name and address from internal RODM tables
by executing a delete object transaction against the method object. A method can
only be freed if it is not assigned as a value to any field or subfield in RODM.
After method has been freed, it cannot be assigned to a field or subfield, and it
cannot be run as an object-independent method until it is re-installed.</p>
        <p>While other methods need to be installed before use, the null method, NullMeth, is
always installed and cannot be freed. An attempt to install or free NullMeth results
in an error return code from RODM. Therefore, the method name NullMeth is
reserved in RODM, and cannot be used for a user-written method. Other methods
that are supplied with the NetView program must be installed before use just like
user-written methods.</p>
        <p><b>Synchronous and Asynchronous Execution of Functions</b></p>
        <p>If a method triggers a function or another method, the triggered function or
method runs synchronously with the triggering method. The triggering method
stops running and does not resume processing until the triggered function or
method finishes and returns. The method API provides the
EKG_MessageTriggeredAction function, which provides a method with the
capability to trigger a function or another method to run asynchronously with it.
The triggering method continues to run while the triggered function or method
starts, processes, and finishes.</p>
        <p>Although the EKG_MessageTriggeredAction function is intended to allow an
object-specific method to access entities in the RODM data cache other than the
one it is associated with, it can also be called by an object-independent method.
Also, the EKG_MessageTriggeredAction function enables the following functions to
run asynchronously with the triggering method: </p>
        <p>Change or swap the contents of a field or subfield</p>
        <p>Link or unlink two objects</p>
        <p>Revert inheritance of a field</p>
        <p>Create and delete objects</p>
        <p><b>Method Anchor Service</b></p>
        <p>RODM provides a callable method anchor service that will return a pointer to an
8-byte work area. This area is cleared to zeros prior to invoking the method, and
the contents of the area is preserved when the method causes other methods to be
triggered.</p>
        <p>It is intended that this area be used for communication between the component
modules of large, complex methods. Note that it cannot be used to communicate
between methods, because it is cleared by RODM each time a method is run.</p>
        <p>Run the EKGMANC service routine using the following code for PL/I:</p>
        <p><i>DCL WORK_AREA CHAR(8) BASED(WORK_AREA_PTR);</i></p>
        <p><i>DCL WORK_AREA_PTR POINTER;</i></p>
        <p><i>CALL EKGMANC(WORK_AREA_PTR);</i></p>
        <p>For C use the following code:</p>
        <p><i>char *work_area_ptr;</i></p>
        <p><i>EKGMANC(&work_area_ptr);</i></p>
        <p>There is no return or reason code from the EKGMANC call. The address of the
work area is always returned.</p>
        <p><b>Coding Your RODM Method</b></p>
        <p>The following sections describe some of the details of writing your own methods.
These sections include information about compiler options, link-editing, and
restrictions. Be sure to review both the general restrictions and the restrictions for
the programming language you are using.</p>
        <p><b>Installation Written Methods</b></p>
        <p>Installation written methods can be written in PL/I or in C. These methods can use
the multicultural support of the PL/I language. DBCS character strings can be
manipulated as graphic constants.</p>
        <p>Installation supplied methods can reference RODM data stored in either SBCS or
DBCS formats.</p>
        <p>After your method has been coded, you can run the method using test data and
debugging aids to find any syntax or logic errors. Refer to the <i>IBM Tivoli NetView
            for z/OS Programming: PL/I and</i> C for additional information. Install your method by
link-editing it to the appropriate user library pointed to by the STEPLIB DD
statement in your start up JCL for RODM.</p>
        <p><b>NetView Methods</b></p>
        <p>The NetView program includes a basic set of RODM methods. You can write your
own methods in either PL/I or C. You can supplement or replace methods that are
supplied with the NetView program with your methods. All methods that are
supplied with the NetView program reside in the CNMLINK target library for the
NetView program.</p>
        <p><b>Note</b>: Enterprise PL/I for z/OS cannot be used to compile method code, including
your method code and method code that is supplied with the NetView program.</p>
        <p>Currently, the following methods are supplied with RODM:</p>
        <p><b>EKGNOTF</b></p>
        <p>Notify for any change</p>
        <p><b>EKGNLST</b></p>
        <p>Notify if changed value is equal to one value in a list of values</p>
        <p><b>EKGNEQL</b></p>
        <p>Notify if changed value is equal to a specific value</p>
        <p><b>EKGNTHD</b></p>
        <p>Notify if changed value is within a specified threshold</p>
        <p><b>EKGCTIM</b></p>
        <p>Change method to trigger an Object-independent method to complete an
action asynchronously</p>
        <p><b>EKGMIMV</b></p>
        <p>Named method to increment a value</p>
        <p><b>EKGSPPI</b></p>
        <p>Object-independent method used by the RODM automation platform</p>
        <p>All notification methods return, in the notification block, the current value,
previous value, and time stamp (if these subfields are defined) from the field that
is causing the notification message.</p><br>
        <p>The methods that are supplied with the NetView program for RODM are described
in the following sections on a functional basis. All parameters that are passed to
methods are specified as SelfDefining data strings.</p>
        <p><b>Programming Language Specific Preprocessor Statements</b></p>
        <p>When compiling your program or linking your source code, add the following
preprocessor statements.</p>
        <p><b>Compiling IBM C Methods</b></p>
        <p>If you are compiling your methods using the IBM C language, follow these
guidelines:</p>
        <p>Code the following pragma statement:
            #<i>pragma linkage(csect,PLI)</i>
            where <i>csect</i> is the name of the external entry-point <i>csect</i>.</p>
        <p>If any RODM control blocks are referenced in the modules, include file
EKG3CINC.H in your source file. This file includes all of the RODM function
and response blocks, and the function prototype statements for the RODM entry
points EKGMANC, EKGUAPI, EKGMAPI, and EKGWAIT.</p>
        <p>v If no RODM control blocks are referenced in the modules but the modules do
call EKGMANC, EKGUAPI, EKGMAPI, or EKGWAIT, include file EKG3CEEP.H
in your source file.</p>
        <p>v Do not specify the RENT option when compiling.</p>
        <p>The following is an example of IBM C source for coding a method:</p>
        <p><i>#pragma linkage(thisproc,PLI)
#include "EKG3CINC.H"
/* or */
#include "EKG3CEEP.H"
void thismethod(void arg)
{
/* code */
}</i></p>
        <p><b>Compiling IBM PL/I Methods</b></p>
        <p>If you are compiling your methods using the IBM PL/I language, follow these
guidelines:</p>
        <p>If any RODM control blocks are referenced in the modules, include file
EKG1IINC in your source file. This file includes all of the RODM function and
response blocks, and the function prototype statements for the RODM entry
points EKGMANC, EKGUAPI, EKGMAPI, and EKGWAIT. </p>
        <p>If no RODM control blocks are referenced in the modules but the modules do
call EKGMANC or EKGMAPI, include file EKG1IEEP in your source file. </p>
        <p>Specify the REENTRANT option when compiling</p>
        <p>Specify the MACRO preprocessor compiler option if you include RODM macros
in your method.</p>
        <p>The following is an example of IBM PL/I source for coding a method:</p>
        <p><i>*PROCESS MACRO;
thismethod: proc;
%include ekglib(EKG1IINC);
or
%include ekglib(EKG1IEEP);
/* code */
end thismethod;</i></p>
        <p><b>Linking Methods that Call EKGMAPI Directly</b></p>
        <p>Specify the following link-edit control statements when linking a method that calls
EKGMAPI directly:</p>
        <p><i>method object code>
INCLUDE SYSLIB(EKGMAPI)
ENTRY method_name
NAME method_name(R)</i></p>
        <p>Specify these link-edit options:</p>
        <p>AMODE=31</p>\
        <p>RMODE=ANY or RMODE=24</p>
        <p>RENT</p>
        <p><b>Restrictions on Methods</b></p>
        <p>All RODM methods must run in PSW key 8, which is the default. Do not change
the PSW key in any method.</p>
        <p><b>PL/I Language Restrictions</b></p>
        <p>Installation defined methods written in PL/I require a PL/I compiler that is
supported by RODM. These PL/I programs are expected to clean up after
execution is complete for a particular invocation; all dynamically allocated storage
is freed. In addition, PL/I programs that run in the RODM address space must
observe certain the following restrictions:</p>
        <p>Use of PLITEST
The PLITEST facility is not available to programs running in the RODM address
space. </p>
        <p>v Use of FETCH and RELEASE
PL/I procedures cannot be fetched or released by other PL/I procedures. The
user API supports adding and deleting methods. These services can be used in
place of FETCH and RELEASE.</p>
        <p>Use of DATE built-in function
The PL/I DATE built-in function cannot be called by a program running in the
RODM address space.</p>
        <p>Use of TIME built-in function
The PL/I TIME built-in function cannot be called by a program running in the
RODM address space.</p>
        <p>Use of file I/O
PL/I file I/O cannot be used by programs running in the RODM address space.
No RODM method attempts to access SYSPRINT. However, the RODM output
to log function can be used for file I/O.</p>
        <p>Interlanguage communication</p>
        <p>Interlanguage calls to COBOL and FORTRAN routines cannot be used. Only
interlanguage calls to C and assembler are permitted.</p>
        <p>Delays
The execution of a method cannot be suspended. Methods complete as soon as
possible.</p>
        <p>Wait
The execution of a method cannot be suspended.</p>
        <p>Use of PL/I DISPLAY statement
The PL/I DISPLAY statement writes its output to the RODM type-1 log record.
Because of performance and logging impacts, the PL/I DISPLAY statement is not
usually used. Instead, use the EKG_OutputToLog API function.</p>
        <p>Use of PL/I multitasking
The PL/I multitasking facilities cannot used. Task management is handled by
RODM facilities and not the PL/I facilities. The task, event, and priority options
of the CALL statement cannot be used, and do not use the COMPLETION,
STATUS, and PRIORITY built-in functions.</p>
        <p>Use of MAIN option
User methods cannot be coded with the PL/I MAIN option of the PROCEDURE Statement.</p>
        <p>Linkage field
All methods must be reentrant. In addition to writing reentrant code, the
REENTRANT option of the PROCEDURE statement must be used.</p>
        <p>Cannot use controlled storage variables, or anything using pseudo-register
vectors, such as file I/O and fetch/release.</p>
        <p>Programs must not request CHECKPOINT, SORT, or PLIDUMP</p>
        <p>PL/I options for CHECK and FLOW must not be used</p>
        <p>Use of On-Units and Signal – PL/I programs cannot perform attention handling; that On-unit will not get
control – PL/I programs must not signal ERROR or FINISH
– PL/I programs must not contain On-error or On-finish statements</p>
        <p><b>C Language Restrictions</b></p>
        <p>Methods must be compiled using the NORENT option. Methods must not be
prelinked using the C prelink facility</p>
        <p>The following C functions cannot be used in RODM methods:</p>
        <p>Atexit()</p>
        <p>Exit()</p>
        <p>Main()</p>
        <p>All file and stream input/output statements and library functions</p>
        <p>Do not specify the static storage class specifier for any data in a method.</p>
        <p>The RODM output to log function can be used for file input/output.</p>
        <p><b>Restrictions in General</b></p>
        <p>An object-specific method can query and manipulate only the object or class with
which the method is associated.</p>
        <p>The following are restrictions on methods:</p>
        <p>Named methods:</p>
        <p>Named methods can be run to run synchronously with the caller directly from
the user API, by an object-independent method through the method API, or by a
named method through the method API. Also, named methods can be triggered
to run asynchronous to the caller through the message interface provided in the
method API.</p>
        <p>Named methods cannot be triggered for asynchronous execution through the
user API.</p>
        <p>Object-independent methods:</p>
        <p>Object-independent methods can be run to run synchronously with the caller
from the user API or the method API. Also, they can be triggered from any
method, through the message interface provided in the method API, to run
asynchronous to that method.
Object-independent methods cannot be triggered for asynchronous execution
through the user API</p>
        <p>Change methods:</p>
        <p>Change methods cannot be used on system-defined fields. See “System-Defined
Fields” on page 207 for a complete list of these fields.
Change methods used on LINK fields, that is the fields of data type ObjectLink
or ObjectLinkList, are triggered by EKG_LinkTrigger and EKG_UnlinkTrigger
functions. These change methods have the following restrictions:</p>
        <p>They cannot change fields. – They cannot perform a link or unlink function. – They must set a return code if the return code is non-zero. - A zero return code allows the link or unlink to continue. - A non-zero return code prohibits the link or unlink. - If the change methods exist, the return codes from the change methods
defined to both objects must be zero in order for the link or unlink to
continue.</p>
        <p>Notification methods:</p>
        <p>A particular combination of a User_appl_ID, notification method, SubscribeID,
and long-lived parameters uniquely specify a notification method and can be
assigned only one time to a particular notification subfield.</p>
        <p>All methods:</p>
        <p>All methods must be written as reentrant. – Methods cannot query a notification queue or suspend their own execution. – When RODM is operating on a z/OS system, methods must adhere to
operating system constraints placed on applications running in cross-memory
mode; for example, the methods must not use any service that requires the
execution of an IBM z/Architecture® SVC instruction. – If a method uses recovery routines such as ESTAE, ESTAX, SPIE, or STAE,
the recovery routines must be set up to percolate so that RODM regains
control after any abend. – Use of the method API to synchronously run another method must not cause
recursive execution of any previously run method. – The response block overflow buffer is not available to methods. If the
response block supplied by a method is too small for the data returned by the
function, the data that does not fit in the supplied response block is
discarded.</p>
        <p><b>RODM Method Services</b></p>
        <p>Some RODM functions can be used by all types of methods; others can be used
only by certain types of methods. The following sections lists the types of methods
and the RODM functions that each can use.</p>
        <p><b>Services Available to both Object-Specific and
Object-Independent Methods</b></p>
        <p>When you design your program, you can implement the following functions,
available for use in both object-independent and object-specific methods.</p>
        <p>Querying RODM Data:</p>
        <p>EKG_QueryField (See “EKG_QueryField - Query a Field” on page 416) – EKG_QueryMultipleSubfields (See “EKG_QueryMultipleSubfields - Query
Multiple Value Subfields” on page 424) – EKG_QuerySubfield (See “EKG_QuerySubfield - Query a Subfield” on page
432) – EKG_QueryEntityStructure (See “EKG_QueryEntityStructure - Query
Structure of an Entity” on page 415) – EKG_QueryFieldStructure (See “EKG_QueryFieldStructure - Query Structure
of a Field” on page 421) – EKG_QueryFieldID (See “EKG_QueryFieldID - Query Field Identifier” on
page 418) – EKG_QueryFieldName (See “EKG_QueryFieldName - Query a Field Name”
on page 419)</p>
        <p>Actions against RODM Data:</p>
        <p>– EKG_ChangeField (See “EKG_ChangeField - Change a Field” on page 380) – EKG_ChangeMultipleFields (See “EKG_ChangeMultipleFields - Change
Multiple Fields” on page 381) – EKG_ChangeSubfield (See “EKG_ChangeSubfield - Change a Subfield” on
page 383) – EKG_RevertToInherited (See “EKG_RevertToInherited - Revert to Inherited
Value” on page 435) – EKG_AddNotifySubscription (See “EKG_AddNotifySubscription - Add
Notification Subscription” on page 377) – EKG_DeleteNotifySubscription (See “EKG_DeleteNotifySubscription - Delete
Notification Subscription” on page 398) – EKG_TriggerNamedMethod (See “EKG_TriggerNamedMethod - Trigger a
Named Method” on page 445)</p>
        <p>Additional Method Support:</p>
        <p>EKG_SendNotification
– EKG_MessageTriggeredAction
– EKG_SetReturnCode – EKG_OutputToLog
– EKG_ResponseBlock (can be used in named and query object-specific
methods and object-independent methods) – EKG_QueryFunctionBlockContents</p>
        <p>This list of query and action functions is a subset of the transactions available to
RODM users through the user API.</p>
        <p>Both the user API and method API use the same function blocks to specify the
function requested for queries and actions with the queries generating responses
that are returned in response blocks. Also, a named method can generate data that
is returned in a response block.</p><br>
        <p>See Chapter 11, “Writing Applications that Use RODM,” on page 305 for the
formats for all these function blocks and response blocks. As in the user API, the
user of the method API is responsible for allocating and freeing the storage in
which function and response blocks reside. The method API function blocks for the
additional method support functions are described in this section</p>
        <p><b>Other Services Available to Object-Independent Methods</b></p>
        <p>The following additional services are available to object-independent methods
through the method API and the user API. </p>
        <p>EKG_LinkNoTrigger, EKG_LinkTrigger (See “EKG_LinkNoTrigger, EKG_LinkTrigger - Link Two Objects” on page 407)
v EKG_UnlinkNoTrigger, EKG_UnlinkTrigger (See “EKG_UnlinkNoTrigger, EKG_UnlinkTrigger - Unlink Two Objects” on page 448)
v EKG_CreateObject (See “EKG_CreateObject - Create an Object” on page 393)
v EKG_DeleteObject (See “EKG_CreateObject - Create an Object” on page 393)
v EKG_TriggerOIMethod (See “EKG_TriggerOIMethod - Trigger an
Object-Independent Method” on page 447)</p>
        <p><b>Other Services Available to Object-Specific Methods</b></p>
        <p>The following additional services are available only to object-specific methods:</p>
        <p>EKG_WhereAmI</p>
        <p>EKG_QueryObjectName</p>
        <p><b>Services Available to the Initialization Method</b></p>
        <p>The initialization method is the only method that can use the following functions.
The method can run these functions at RODM initialization time to create the
RODM data structure and load the data into the RODM data cache.</p>
        <p>Administrative functions</p>
        <p>EKG_CreateClass (See “EKG_CreateClass - Create a Class” on page 390) – EKG_CreateField (See “EKG_CreateField - Create a Field” on page 391) – EKG_CreateSubfield (See “EKG_CreateSubfield - Create a Subfield” on page
394)</p>
        <p>Control functions</p>
        <p>EKG_Checkpoint (See “EKG_Checkpoint - Checkpoint RODM to DASD” on
page 384)</p>
        <p>The access to the above mentioned functions is similar to the access available
through the user API. These functions are run by calls to RODM using the method
API. Use of these functions requires the standard function block definitions.</p>
        <p>The method API functions and interfaces available to the initialization method also
include all those enabled in object-independent methods, with the following
exceptions. Do not use these exceptions within the initialization method.</p>
        <p>EKG_SendNotification</p>
        <p>– This function fails because no Notification_queues can be registered at the
time the initialization method is running.</p>
        <p>EKG_ResponseBlock</p>
        <p>No response block is passed to the initialization method, so the data is lost.</p>
        <p>EKG_QueryFunctionBlockContents</p>
        <p>No function block is used to initiate the initialization method execution, so no
data is available. </p>
        <p>EKG_CreateObject to create an EKG_NotificationQueue object</p>
        <p>Notification queues are named by concatenating a User_appl_ID to the queue
name. This function always fails for the initialization method because no
User_appl_ID is available during initialization.</p>
        <p>If the initialization method uses the message interface to start an asynchronous
task, RODM initialization continues without waiting for the completion of that
asynchronous task.</p>
        <p><b>RODM Method Library</b></p>
        <p>To access the method API services, RODM provides a library that contains entry
points for method API services. This library is called the RODM Method Library
and is given the default name CNMLINK.</p>
        <p>This library is especially intended for use with C and PL/I programs. To access a
service such as EKGMAPI, declare EKGMAPI as an external entry in your
program. To resolve the external name, use the CNMLINK library.</p>
        <p>Member EKGMIMV of data set CNMSAMP in the sample library contains an
example showing how EKGMAPI can be called from a named method to
increment the value of a specified field by the value of a field.</p>
        <p><b>Chapter 14. Application Programming Reference</b></p>
        <p>The details of all transactions against RODM data are specified in function blocks.
A user builds a function block and passes it to RODM to request a desired
transaction. All function blocks contain a Function_ID which specifies the function
being requested from RODM.</p>
        <p><b>Summarizing RODM Functions</b></p>
        <p>This chapter describes each of the RODM functions. The major categories of
functions follow:</p>
        <p>Access functions</p>
        <p>Control functions</p>
        <p>Administrative functions</p>
        <p>Action functions</p>
        <p>Query functions</p>
        <p>RODM user API services</p>
        <p>RODM method API services</p>
        <p>See Chapter 11, “Writing Applications that Use RODM,” on page 305 for an
explanation of how function blocks are used in application programs. See
Chapter 13, “Writing RODM Methods,” on page 343 for an explanation of how
function blocks are used in methods.</p>
        <p><b>Access Functions</b></p>
        <p>Access functions enable a user application program to connect to and disconnect
from RODM</p>
        <p><b>EKG_Connect or EKG_ConnectLong: Connect to RODM</b></p>
        <p>The connect function is called to connect the user to RODM.</p>
        <p><b>EKG_Disconnect: Disconnect from RODM</b></p>
        <p>The disconnect function is called to end the connection between the user
and RODM.</p>
        <p>Control Functions</p>
        <p>Control functions allow a user application program that has the appropriate access
level to checkpoint RODM data to DASD or to stop RODM, with or without
checkpointing data.</p>
        <p><b>EKG_Checkpoint: Checkpoint RODM</b></p>
        <p>Checkpoint RODM data to DASD.</p>
        <p><b>EKG_Stop: Stop RODM</b></p>
        <p>Stop the RODM subsystem.</p>
        <p><b>Administrative Functions</b></p>
        <p>Use the RODM administrative functions, with the appropriate function blocks
passed as parameters, to delete or create classes, fields, and subfields. Because
response blocks are not needed in administrative calls, set the response block
pointer to null.</p>
        <p>When a RODM class is initially created, it contains the system-defined fields and
the public fields of its primary parent. The values of these fields are inherited from
their primary parent. Classes are differentiated from their parent by the existence
of additional fields or by setting different values in the fields that do exist. Most
frequently, a child class needs to have more fields than exist on the parent. These
additional fields must be explicitly added to the class. RODM has no set limit of
the number of fields a class can contain.</p>
        <p>You can add a field to a class. You can add a subfield only to a field that is already
in place. You cannot add a field directly to an object.</p>
        <p><b>EKG_CreateClass: Create a Class</b></p>
        <p>Create a new class in the RODM data cache.</p>
        <p><b>EKG_CreateField: Create a Field</b></p>
        <p>Add a new field to a class.</p>
        <p><b>EKG_CreateSubfield: Create a Subfield</b></p>
        <p>Add a new subfield to a field in a class.</p>
        <p><b>EKG_DeleteClass: Delete a Class</b></p>
        <p>Remove a class from the RODM data cache.</p>
        <p><b>EKG_DeleteField: Delete a Field</b></p>
        <p>Delete a field from a class.</p>
        <p><b>EKG_DeleteSubfield: Delete a Subfield</b></p>
        <p>Delete a subfield from a field in a class.</p>
        <p><b>Action Functions</b></p>
        <p>Action functions change values, create and delete objects and links between
objects, add and delete notification subscriptions, and trigger named and
object-independent methods. Action functions can be submitted in list form using
the EKG_ExecuteFunctionList function to enable multiple actions with a single
interface call.</p>
        <p><b>EKG_AddNotifySubscription: Add a Notification Subscription</b></p>
        <p>Subscribe to a field.</p>
        <p><b>EKG_AddObjDelSubs: Add an Object Deletion Subscription</b></p>
        <p>Subscribe to an object for notification of deletion.</p>
        <p><b>EKG_ChangeField: Change a Field</b></p>
        <p>Change the value of a field.</p>
        <p><b>EKG_ChangeMultipleFields: Change Multiple Fields</b></p>
        <p>Change the value of multiple fields of an object</p>
        <p><b>EKG_ChangeSubfield: Change a Subfield</b></p>
        <p>Change the value of a subfield.</p>
        <p><b>EKG_CreateObject: Create an Object</b></p>
        <p>Create an object in the RODM data cache.</p>
        <p><b>EKG_DeleteNotifySubscription: Delete a Notification Subscription</b></p>
        <p>Delete a subscription to a field.</p>
        <p><b>EKG_DeleteObject: Delete an Object</b></p>
        <p>Delete an object in the RODM data cache.</p>
        <p><b>EKG_DelObjDelSubs: Delete an Object Deletion Subscription</b></p>
        <p>Delete a subscription to an object.</p>
        <p>EKG_LinkNoTrigger: Link Two Objects
Link two objects; do not run notify methods.
EKG_LinkTrigger: Link Two Objects
Link two objects; run notify methods.
EKG_RevertToInherited: Revert to Inherited Value
Remove the local copy of the data value from a field and replace it with
the inherited value.
EKG_SwapField: Swap a Field
Compare and swap field data with new data.
EKG_SwapSubfield: Swap a Subfield
Compare and swap subfield data with new data.
EKG_TriggerNamedMethod: Trigger a Named Method
Run a named method.
EKG_TriggerOIMethod: Trigger an Object-Independent Method
Run an object independent method.
EKG_UnlinkNoTrigger: Unlink Two Objects
Unlink two objects; do not run notify methods.
EKG_UnlinkTrigger: Unlink Two Objects
Unlink two objects; run notify methods</p>
        <p><b>Query Functions</b></p>
        <p>Query functions enable a user application program to query the values contained
in fields, subfields, notification queues, and access blocks. Query functions can be
submitted in list form using the EKG_ExecuteFunctionList function to enable
multiple actions with a single interface call.</p>
        <p>The contents of the field or information to be queried is returned in the response
block.</p>
        <p>If a field of an object or class is being queried and there is a query method
associated with the field, that query method is run before the contents of the field
is retrieved. That method has the opportunity to change the contents of the field
before the data in the field is read and returned to the caller. A query method can
explicitly set the returned value of the query operation by using the
EKG_ResponseBlock function. If a query method uses the EKG_ResponseBlock
function, RODM does not place any data into the response block.</p>
        <p><b>EKG_Locate: Locate Objects Using Public Indexed Field</b></p>
        <p>Provide a list of all objects in RODM that match a specified search criteria.</p>
        <p><b>EKG_QueryEntityStructure: Query Structure of an Entity</b></p>
        <p>Provide a list of all fields within a class or object, specifying each field's
name, data type, and inheritance state.</p>
        <p><b>EKG_QueryField: Query Field</b></p>
        <p>Obtain the value of a field.</p>
        <p><b>EKG_QueryFieldID: Query Field Identifier</b></p>
        <p>Convert a field name to its field identifier.</p>
        <p><b>EKG_QueryFieldName: Query Field Name</b></p>
        <p>Convert a field identifier to its field name.</p>
        <p><b>EKG_QueryFieldStructure: Query Structure of a Field</b></p>
        <p>Provide organization of a field (that is, data type, local copy indicator, and
subfield map).</p>
        <p><b>EKG_QueryMultipleSubfields: Query Multiple Value Subfields</b></p>
        <p>Obtain the value of multiple subfields for an object</p>
        <p><b>EKG_QueryNotifyQueue: Query Notification Queue</b></p>
        <p>Obtain next queue element, if available.</p>
        <p><b>EKG_QueryResponseBlockOverflow : Query Response Block Overflow</b></p>
        <p>Obtains any overflow response block data.</p>
        <p><b>EKG_QuerySubfield: Query Subfield</b></p>
        <p>Obtain the value of a subfield.</p>
        <p><b>RODM User API Services</b></p>
        <p><b>EKG_ExecuteFunctionList: Execute a List of Function</b></p>
        <p>Enable user application programs to pass a list of RODM functions in a
single function call.</p>
        <p><b>RODM Method API Services</b></p>
        <p>EKG_LockObjectList: Lock List of Objects
This API was used to enable object-independent methods to explicitly lock
objects. It is no longer necessary, but is maintained for compatibility. EKG_MessageTriggeredAction: Trigger an Action by a Message
Provide object-specific methods with the ability to trigger an asynchronous
API function for another object or class.
EKG_QueryFunctionBlockContents: Query Function Block Contents
Provide methods with the contents of the function block of the function
request that triggered the method.
EKG_QueryObjectName: Query Object Name
Allow an object-specific method to convert an ObjectID to the
corresponding object name.
EKG_OutputToLog: Output to Log
Provide the ability to output information to the RODM log.
EKG_ResponseBlock: Output to Response Block
Appends method-defined information to the caller's response block, except
for Query methods, which overwrite the response block.
EKG_SendNotification: Send a Notification
Provide the facility for notification methods to send notification
information blocks to notification queues when a field is changed.
EKG_SetReturnCode: Set Return and Reason Codes
Enable a method to set the return code and reason code for the method
caller. EKG_UnlockAll: Unlock all Held Entities
This method was used to free all locks held. It is no longer necessary, but
is maintained for compatibility. EKG_WhereAmI: Where Am I
Enable an object-specific method to determine the class, object, and field
for which it was triggered.</p>
        <p><b>Function Reference</b></p>
        <p>This section describes each of the functions available from the RODM user
application programming interface and the RODM method application
programming interface. The format of this section is described in “Function
Reference Format.” The functions are listed in alphabetical order by function name.</p>
        <p><b>Function Reference Format</b></p>
        <p>This section describes the format of the RODM function descriptions contained in
this chapter. The functions are listed in alphabetical order by function name.
Following each function name is a function description. Each function description
contains the following reference sections:</p>
        <p>Purpose</p>
        <p>Function block format</p>
        <p>Examples</p>
        <p>Summary</p>
        <p>Usage</p>
        <p>These reference sections are described in the following sections.</p>
        <p><b>Purpose</b></p>
        <p>The purpose section of each function description explains what the function does.</p>
        <p><b>Function block format</b></p>
        <p>The function block format describes the function block that you need to pass to the
function. If the function returns a response block, the response block is also
described in this section.</p>
        <p>The function block format table contains five columns:</p>
        <p><b>Offset</b></p>
        <p>The offset in decimal bytes to the beginning of the parameter</p>
        <p><b>Length</b></p>
        <p>The length in decimal bytes of the parameter. If the length of a parameter
is variable, the length column contains a dash (—) character</p>
        <p><b>Type</b></p>
        <p>The RODM abstract data type of the parameter. A few parameters do not
use the defined RODM abstract data types. The PL/I or data types are
listed for parameters which do not use RODM abstract data types.</p>
        <p><b>Use</b></p>
        <p>The use is either In for data input to the function, or Out for data output
by the function. For reserved fields and fields not used by a particular
function, the use column contains a dash (—).</p>
        <p><b>Parameter Name</b></p>
        <p>The name of the parameter. Each parameter is described in “Function
Parameter Descriptions” on page 452. This is the actual name used in the
example function block or response block supplied with RODM.</p>
        <p><b>Examples</b></p>
        <p>The examples section lists the names of the code examples provided by RODM for
each function. Provided in both PL/I and C, these examples are on the samples
tape that was shipped with the NetView product. Include the example function
block and response block in your user application or method for each function you
plan to use. Use the parameter names that are provided to access the function. This
will limit the impact to your program of any service that might be applied to
RODM.</p>
        <p>The example function blocks and example response blocks for PL/I contain the
            preprocessor macro substitution variable <i>EKG_Boundary</i>. This variable is converted
to UNALIGNED BASED(*), which is required for PL/I programs</p>
        <p>The usage coding examples are pieces of actual code that illustrate how to set up
and call each function. Use the usage coding examples to learn about calling the
function. Note, however, that these examples might not be suitable for inclusion in
your programs.</p>
        <p>The names in the examples table are the member names of each example. The
default data set name for function block samples and response block samples is
NETVIEW.V6R2M1.SCNMMAC1. The default data set name for usage coding
examples is NETVIEW.V6R2M1.CNMSAMP. For example, the complete name of
the function block example in PL/I for the EKG_Connect function is
NETVIEW.V6R2M1.SCNMMAC1(EKG11101). The complete name of the PL/I usage
coding example for this function is NETVIEW.V6R2M1.CNMSAMP(EKG51101).</p>
        <p><b>Summary</b></p>
        <p>The summary table lists the following topics for each function:</p>
        <p><b>Function ID</b></p>
        <p>The function identifier used by RODM to determine which function has
been requested.</p>
        <p><b>Type</b></p>
        <p>The type of function, such as access or query.</p>
        <p><b>User API</b></p>
        <p>Specifies whether this function can be used by user applications.</p>
        <p><b>Object-specific method</b></p>
        <p>Specifies whether this function can be used by object-specific methods.</p>
        <p><b>Object-independent method</b></p>
        <p>Specifies whether this function can be used by object-independent
methods.</p>
        <p><b>Initialization method</b></p>
        <p>Specifies whether this function can be used by initialization methods.</p>
        <p><b>Methods triggered</b></p>
        <p>Specifies whether this function triggers query, change, or notification
methods and which methods are triggered.</p>
        <p><b>Triggered by EKG_MessageTriggeredAction</b></p>
        <p>Specifies whether this function can be run asynchronously by the
EKG_MessageTriggeredAction function.</p>
        <p><b>Authorization</b></p>
        <p>Specifies the minimum authorization level that a user application must be
assigned in order to use this function.</p>
        <p>User applications must be authorized to use specific RODM functions.
Each function specifies the required authorization level. Applications can
use all functions with a required authorization level equal to or less than
the authorization level of the application. Each application's authorization
level is specified when the application User_appl_ID is created in the
security system profile. See the IBM Tivoli NetView for z/OS Security
Reference for information about defining authorization levels.</p>
        <p><b>Usage Notes</b></p>
        <p>This topic provides additional function information and limitations.</p>
        <p>The parameters used by each function are described in “Function Parameter
Descriptions” on page 452. This section describes in general what each parameter
does. Function-specific differences in parameters, such as maximum data length,
are listed in the usage section for the specific function.</p>
        <p>The return codes and associated reason codes issued by RODM functions are listed
in “RODM Return and Reason Codes” on page 459. This section also includes cross
reference tables that list all of the reason codes that each function uses and all of
the functions that use a particular reason code. You can use this information to
design the error handling routines for your user applications and methods.</p>
        <p>The final section in this chapter describes the methods that are supplied with the
NetView program. These include notification and change methods you can use
with RODM. “Supplied Methods” on page 488 describes each method and the
parameters you pass to it.</p>
        <p><b>EKG_AddNotifySubscription - Add Notification Subscription
Purpose</b></p>
        <p>This function adds a notification method to a field on an object or a class. RODM
places the notification method in a subscription list associated with the field. If the
specified notification queue does not exist, RODM creates the notification queue
using the specified User_appl_ID.</p>
        <p><b>Function Block Format</b></p>
        <p><i>Table 37. Function Block for the EKG_AddNotifySubscription Function</i></p>
        <table>
  <tr>
    <th>Offset</th><br>
    <th>Length</th><br>
    <th>Type</th><br>
    <th>Use</th><br>
    <th>Parameter Name</th><br>
  </tr>
  <tr>
    <td>000</td>
    <td>4</td>
    <td>Integer</td>
    <td>In</td>
    <td>Function_id</td>
  </tr>
    <tr>
    <td>004</td>
    <td>4</td>
    <td>Pointer</td>
    <td>In</td>
    <td>Entity_access_info_ptr</td>
  </tr>
    <tr>
    <td>008</td>
    <td>4</td>
    <td>Pointer</td>
    <td>In</td>
    <td>Field_access_info_ptr</td>
  </tr>
    <tr>
    <td>012</td>
    <td>8</td>
    <td>ApplicationID</td>
    <td>In</td>
    <td>User_appl_id</td>
  </tr>
    <tr>
    <td>020</td>
    <td>8</td>
    <td>SubscribeID</td>
    <td>In</td>
    <td>Notification_queue</td>
  </tr>
    <tr>
    <td>028</td>
    <td>8</td>
    <td>Anonymous(8)</td>
    <td>In</td>
    <td>User_word</td>
  </tr>
    <tr>
    <td>036</td>
    <td>8</td>
    <td>ObjectID</td>
    <td>In</td>
    <td>Notify_method</td>
  </tr>
    <tr>
    <td>044</td>
    <td>4</td>
    <td>SelfDefiningDataPtr</td>
    <td>In</td>
    <td>Long_lived_parm</td>
  </tr>
        </table>
    <p>See “Function Parameter Descriptions” on page 452 for more information about the
parameters listed. See “Abstract Data Type Reference” on page 219 for more
information about the abstract data types listed.</p>
            <p><b>Examples</b></p>
            <p><i>Table 38. Example Names for the EKG_AddNotifySubscription Function</i></p>
<table>
  <tr>
    <th>Example</th><br>
    <th>Name</th><br>
    </tr>
    <tr>
    <td>PL/I functionblock</td><br>
    <td>EKG11412</td><br>
    </tr>
    <tr>
    <td>PL/I responseblock</td><br>
    <td>None</td><br>
    </tr>
    <tr>
    <td>PL/I usagecoding</td><br>
    <td>EKG51412</td><br>
    </tr>
    <tr>
    <td>Cfunctionblock</td><br>
    <td>EKG31412</td><br>
    </tr>
    <tr>
    <td>Cresponseblock</td><br>
    <td>none</td><br>
    </tr>
        </table>
    <p><i>Table 38. Example Names for the EKG_AddNotifySubscription Function (continued)</i></p>
        <table>
  <tr>
    <th>Example</th><br>
    <th>Name</th><br>
    </tr>
    <tr>
    <td>Cusagecoding</td><br>
    <td>EKG61412</td><br>
    </tr>
        </table>
        <p><b>Summary</b></p>
        <p><i>Table 39. Summary of the EKG_AddNotifySubscription Function</i></p>
        <table>
    <tr>
    <th>Function</th><br>
    <th>Setting</th><br>
    </tr>
    <tr>
    <td>Functionid</td><br>
    <td>1412</td><br>
    </tr>
     <tr>
    <td>Type</td><br>
    <td>Action</td><br>
    </tr>
    <tr>
    <td>UserAPI</td><br>
    <td>Yes</td><br>
    </tr>
    <tr>
    <td>Object-specificmethod</td><br>
    <td>Yes</td><br>
    </tr>
    <tr>
    <td>Object-independentmethod</td><br>
    <td>Yes</td><br>
    </tr>
    <tr>
    <td>Initialisationmethod</td><br>
    <td>Yes</td><br>
    </tr>
    <tr>
    <td>Methodstriggered</td><br>
    <td>Notification method of MyObjectChildren
field of the EKG_NotificationQueue class
triggered if the notification queue object is created</td><br>
    </tr>
    <tr>
    <td>Triggered by the
EKG_MessageTriggeredAction function</td><br>
    <td>No</td><br>
    </tr>
     <tr>
    <td>Authorization</td><br>
    <td>3</td><br>
    </tr>
        </table>
        <p><b>Usage</b></p>
        <p>See “RODM Notification Process” on page 323 for more information about
notification subscriptions.</p>
            <p>A notification subscription, consisting of a User_appl_ID, Notification_queue,
method ObjectID, and Long_lived_parm is added to a field one time. If a second
request specifying the same information is sent, the request is rejected.</p>
        <p>The class, object, and field access information from the function block specify
where the subscription is to be installed. If the value subfield of the designated
field is changed by the EKG_ChangeField or EKG_ChangeMultipleFields functions,
the requested notification method is run.</p>
        <p>When a notification method is run, it is provided the value of the
Long_lived_parm field from the function block. The method cannot modify the
Long_lived_parm.</p>
        <p>Users can assign notification subscriptions to both an object and its parent class
where both are run when a change is made to the object field. When these
notifications are added, RODM does not validate that duplicate subscriptions have
not been added between the class and object. Duplicate subscriptions are rejected
only at the individual class or object level.</p>
        <p><b>EKG_AddObjDelSubs - Add Object Deletion Subscription
Purpose</b></p>
        <p>This function adds a deletion-subscription to an object; RODM sends you a
notification block if the object is deleted.</p>
        <p><b>Function Block Format</b></p>
        <img src="tab1.jpg">
        <p>See “Function Parameter Descriptions” on page 452 for more information about the
parameters listed. See “Abstract Data Type Reference” on page 219 for more
information about the abstract data types listed.</p>
        <p><b>Examples</b></p>
        <p><i>Table 41. Example Names for the EKG_AddObjDelSubs Function</i></p>
        <img src="tab2.jpg">
        <p><b>Summary</b></p>
        <p><i>Table 42. Summary of the EKG_AddObjDelSubs Function</i></p>
        <img src="tab3.jpg">
        <p><b>Usage</b></p>
        <p>A deletion-notification subscription, consisting of a User_appl_ID,
Notification_queue, and Long_lived_parm, is added to an object one time. If a
second request specifying the same information is sent, the request is rejected.</p>
        <p>The object access information from the function block specifies where the
subscription is to be installed. If the designated object is deleted by the
EKG_DeleteObject function, a notification block is sent to the user application. The
content of the notification block is the output from the EKG_QueryNotifyQueue
function. For more information, see “EKG_QueryNotifyQueue - Query Notification
Queue” on page 427.</p>
        <p><b>EKG_ChangeField - Change a Field
Purpose</b></p>
        <p>This function changes the value of a field of either an object or a class. This
function triggers any change or notification methods that are defined on the field.</p>
        <p><b>Function Block Format</b></p>
        <p><i>Table 43. Function Block for the EKG_ChangeField Function</i></p>
        <img src="tab4.jpg">
        <p>Note that the Subfield parameter at offset 012 is not currently used</p>
        <p>See “Function Parameter Descriptions” on page 452 for more information about the
parameters listed. See “Abstract Data Type Reference” on page 219 for more
information about the abstract data types listed.</p>
        <p><b>Examples</b></p>
        <p><i>Table 44. Example Names for the EKG_ChangeField Function</i></p>
        <img src="tab5.jpg">
        <p><b>Summary</b></p>
        <p><i>Table 45. Summary of the EKG_ChangeField Function</i></p>
        <img src="tab6.jpg">
        <p><b>Usage</b></p>
        <p>The new value pointed to by New_data_ptr must be of the same data type as the
target field being changed. The new value must be formatted correctly for that
data type. The Data_type field must specify the same data type as the target field.</p>
        <p>You cannot use this function to change fields that have a data type of ObjectID,
ObjectIDList, ObjectLink, ObjectLinkList, ClassID, ClassIDList, or ClassLinkList.
These fields are set either by RODM, or by the LINK and UNLINK transactions.</p>
        <p>You cannot use this function to change the RODM system-defined fields that have
read-only access, such as MyName and MyID.</p>
        <p>Multiple field values can be changed using the EKG_ChangeMultipleFields
function.</p>
        <p><b>EKG_ChangeMultipleFields - Change Multiple Fields
Purpose</b></p>
        <p>This function enables you to change the value of multiple fields of an object. This
function triggers change and notification methods that are defined on the field.</p>
        <p>Function Block Format</p>
        <p><i>Table 46. Function Block for the EKG_ChangeMultipleFields Function</i></p>
        <img src="tab7.jpg">
            
    <p><i>Table 46. Function Block for the EKG_ChangeMultipleFields Function (continued)</i></p>
        <img src="tab8.jpg">
        <p>See “Function Parameter Descriptions” on page 452 for more information about the
parameters listed. See “Abstract Data Type Reference” on page 219 for more
information about the abstract data types listed.</p>
        <p><b>Examples</b></p>
        <p><i>Table 47. Example Names for the EKG_ChangeMultipleFields Function</i></p>
        <img src="tab9.jpg">
        <p><b>Summary</b></p>
        <p><i>Table 48. Summary of the EKG_ChangeMultipleFields Function</i></p>
        <img src="tab10.jpg">
        <p><b>Usage</b></p>
        <p>The new value pointed to by New_data_ptr must be of the same data type as the
target field being changed. The new value must be formatted correctly for that
data type. The Data_type field must specify the same data type as the target field.</p>
<p>You cannot use this function to change fields that have a data type of ObjectID,
ObjectIDList, ObjectLink, ObjectLinkList, ClassID, ClassIDList, or ClassLinkList.
These fields are set either by RODM or by the LINK and UNLINK transactions.</p>
        <p>You cannot use this function to change the RODM system-defined fields that have
read-only access, such as MyName and MyID.</p>
        <p><b>EKG_ChangeSubfield - Change a Subfield
Purpose</b></p>
        <p>This function enables you to change the value of a subfield without triggering
change and notification methods.</p>
        <p><b>Function Block Format</b></p>
        <p><i>Table 49. Function Block for the EKG_ChangeSubfield Function</i></p>
        <img src="tab11.jpg">
        <p>See “Function Parameter Descriptions” on page 452 for more information about the
parameters listed. See “Abstract Data Type Reference” on page 219 for more
information about the abstract data types listed.</p>
        <p><b>Examples</b></p>
        <p><i>Table 50. Example Names for the EKG_ChangeSubfield Function</i></p>
        <img src="tab12.jpg">
        <p><b>Summary</b></p>
        <p><i>Table 51. Summary of the EKG_ChangeSubfield Function</i></p>
        <img src="tab13.jpg">
        <p><i>Table 51. Summary of the EKG_ChangeSubfield Function (continued)</i></p>
        <img src="tab14.jpg">
        <p>Usage</p>
        <p>If the value subfield is to be changed, the data type of the new data must be
identical with that of the field. For other subfields, the data type of the subfield is
determined by the subfield type, and RODM checks that the data_type field in the
function block is compatible with the specified subfield.</p>
        <p>The change of a value subfield does not cause the prev_val and timestamp
subfields to be updated, nor does it run a change or notification method.</p>
        <p><b>EKG_Checkpoint - Checkpoint RODM to DASD
Purpose</b></p>
        <p>This function causes RODM to write a copy of its in-storage data to a checkpoint
data set. Use this checkpoint data set to recover RODM data after a system failure.</p>
        <p><b>Function Block Format</b></p>
        <p><i>Table 52. Function Block for the EKG_Checkpoint Function</i></p>
        <img src="tab15.jpg">
        <p>See “Function Parameter Descriptions” on page 452 for more information about the
parameters listed. See “Abstract Data Type Reference” on page 219 for more
information about the abstract data types listed.</p>
        <p><b>Examples</b></p>
        <p><i>Table 53. Example Names for the EKG_Checkpoint Function</i></p>
        <img src="tab16.jpg">
        <p><b>Summary</b></p>
        <p><i>Table 54. Summary of the EKG_Checkpoint Function</i></p>
        <img src="tab17.jpg">
        <p><i>Table 54. Summary of the EKG_Checkpoint Function (continued)</i></p>
        <img src="tab18.jpg">
        <p><b>Usage</b></p>
        <p>The EKG_Checkpoint function writes RODM data to predefined and preallocated
VSAM linear data sets, which are called RODM checkpoint data sets.</p>
        <p>The checkpoint function is controlled using the CHECKPOINT_FUNCTION
statement in member EKGCUST. Use this statement to either disable the
checkpoint function or control how the checkpoint function reacts when a
checkpoint failure occurs. See the IBM <i>Tivoli NetView for z/OS Administration
            Reference for more information.</i></p>
        <p>The data that the EKG_Checkpoint function writes to the checkpoint data sets
includes the following:</p>
        <p>The RODM master window: a RODM data area that resides in the RODM
address space and contains RODM system information. The RODM master
window data is written to the master window checkpoint file.</p>
        <p>RODM translation window: a RODM data area that resides in the RODM
address space and contains the address information that enables correct data
mapping and addressing in the RODM data cache. RODM translation window
data is written to the translation window checkpoint file. </p>
        <p>RODM data windows: RODM data areas that reside in data spaces and contain
the actual data in the data cache. RODM data-window data is written to data
window checkpoint files.</p>
        <p>The checkpoint process includes the following steps:</p>
        <p>1. Begin checkpoint: RODM sends a message to the console, notifying the
operator that RODM is quiescing.</p>
        <p>2. Quiescing: during the checkpoint quiesce period, RODM allows method API
requests, but rejects new user API requests. At the end of the quiesce period, if
no user API, method API, or asynchronous transactions are still running,
RODM proceeds to the next step in the checkpoint process, first stage
checkpoint. Otherwise, RODM issues a Write-To-Operator with Reply (WTOR)
message requesting directions from the operator. The operator must then select
one of three options:</p>
        <p><b>Option Meaning</b></p>
        <p>1 Perform the quiesce again. Choose this option if a checkpoint is really
desired, but give RODM another quiesce period to successfully quiesce.</p>
        <p>2 Unconditionally, start first stage checkpoint. Choose this option if a
checkpoint is immediately necessary or after having tried option one.</p>
        <p>3 Stop the checkpoint request. Choose this option if option one has been
attempted or if critical RODM tasks must not be stopped.</p>
        <p>3. First stage checkpoint: after the quiescence time period ends and all
transactions have finished processing or the operator has requested an
unconditional checkpoint, RODM writes the master window and the translation
windows to their respective checkpoint files.</p>
        <p>4. Second stage checkpoint: after the first stage checkpoint ends, RODM sends a
message to the console notifying the operator that transactions can now
resume. RODM then begins writing the data windows, one at a time, to the
data window checkpoint files. User applications can make transaction requests
during this checkpoint stage. However, a transaction will fail if the specific data
window that it needs access to is being written to a data window checkpoint
file or has not yet been written to a data window checkpoint file.</p>
        <p>5. End of checkpoint: after all data windows have been written to data window
checkpoint files, RODM sends a message to the console notifying the operator
that the checkpoint process has completed, and two EKG_System object fields
are updated, depending on whether or not the checkpoint process was
successful.</p>
        <p>The EKG_LastCheckpointID field of the EKG_System object is updated by
RODM to reflect the transaction ID of the of the last checkpoint transaction if
the checkpoint process is successful. Otherwise, the EKG_LastCheckpointID
field remains unchanged.</p>
        <p>The EKG_LastCheckpointResult field of the EKG_System object is updated with
the current transaction ID for a checkpoint process issued from a MODIFY
command, or the transaction ID of the user API requesting the checkpoint
process. The EKG_LastCheckpointResult field also reflects the result of the
checkpoint process by use of return and reason codes. Application programs
that are subscribed to this field receive notification that the checkpoint process
has completed.</p>
        <p>With the exception of the checkpoint process, all transactions issued across the
RODM user API are synchronous in that the user does not regain execution control
until the transaction has completed. With the checkpoint process, the application
regains control when the checkpoint request has been recorded. The checkpoint
operation is actually processed asynchronously with other processing in the
application. This same asynchronous processing for the checkpoint process also
applies to an operator-requested checkpoint process, through the MODIFY
command.</p>
        <p><b>Coding Checkpoint Control</b></p>
        <p>RODM updates the EKG_LastCheckpointResult field in the EKG_System class each
time RODM completes a checkpoint operation. The EKG_LastCheckpointResult
field contains the transaction ID of the transaction requesting the checkpoint
operation and the return and reason codes indicating the result of the checkpoint
operation. Applications can subscribe to this field to be notified of the completion
of each checkpoint operation.</p>
        <p>Subscribe to the EKG_LastCheckpointResult field to be notified of the result of the
checkpoint. The user can then query the field and determine the result of the
checkpoint operation. If the checkpoint operation is not successful, the user can
then determine why the checkpoint process failed.</p>
        <p>A user application can keep a record or journal of its transactions with RODM. If
RODM fails between checkpoint operations, the application can then determine
which transactions have been checkpointed by RODM and which transactions have
to be resent. All transactions in that journal numerically the same or lower than the
EKG_LastCheckPointID field are reflected in the checkpoint data sets of the
successfully completed checkpoint operations and can be erased from the journal.
All transactions numerically higher than the EKG_LastCheckPointID field have to
be reset to restore RODM to its status before the failure.</p>
        <p>From the beginning of a checkpoint operation until stage 1 is completed, RODM
rejects any additional transaction requests and provides a return code and reason
code identifying that condition if keyword TRANSPARENT_CHECKPOINT=NO is
specified in the customization file.</p>
        <p>User applications can subscribe to the EKG_LastCheckpointID field, the
EKG_LastCheckpointResult field, or to both fields, using the
EKG_AddNotifySubscription function. See “EKG_AddNotifySubscription - Add
Notification Subscription” on page 377. You can use the EKGNOTF notification
method that is supplied with the NetView program for this subscription. See
“RODM Notification Methods” on page 489 for a description of EKGNOTF.</p>
        <p><b>EKG_Connect - Connect to RODM
Purpose</b></p>
        <p>The connect function enables an application program to use RODM. This is the
first function that the application can issue to RODM.</p>
        <p><b>Function Block Format</b></p>
        <p><i>Table 55. Function Block for the EKG_Connect Function</i></p>
        <img src="tab19.jpg">
        <p>See “Function Parameter Descriptions” on page 452 for more information about the
parameters listed. See “Abstract Data Type Reference” on page 219 for more
information about the abstract data types listed.</p>
        <p><b>Examples</b></p>
        <p><i>Table 56. Example Names for the EKG_Connect Function</i></p>
        <img src="tab20.jpg">
        <p><b>Summary</b></p>
        <p><i>Table 57. Summary of the EKG_Connect Function</i></p>
        <img src="tab21.jpg">
        <p><b>Usage</b></p>
        <p>The User_appl_ID is used to determine the users access authority and to associate
registered event control blocks (ECBs) with the appropriate user.</p>
        <p>If the system on which RODM is installed is protected by a system authorization
facility, the user can connect to RODM using a blank user ID. RODM obtains the
user ID from the system authorization facility and uses it to determine the user's
access authority in RODM. If the system is not protected by a system authorization
facility, the user cannot connect to RODM using a blank user ID.</p>
        <p>When a user application issues an EKG_Connect function request, RODM creates a
user object from the EKG_User system-defined class.</p>
        <p>An access block, as described in “Access Block” on page 309, must be passed. The
user's sign_on_token parameter in the access block is set by RODM. This
parameter must not be changed by the user application for subsequent calls to
RODM.</p>
        <p>A user can disconnect from RODM without purging the subscription notification
queue. Before the notification queues that are owned by this user application ID
can again be posted, all ECB addresses associated with all notification queues for
this user and with subscription notifications must be reset for the new address
space.</p>
        <p>All tasks in the address space from which the EKG_Connect function was issued
can access RODM either by connecting to RODM with unique, RODM authorized
user IDs, or by using the sign_on_token. The sign_on_token is not valid when the
connecting TCB ends or the EKG_Disconnect function is performed.</p>
        <p><b>EKG_ConnectLong - Connect to RODM
Purpose</b></p>
        <p>The connectlong function enables an application program to use RODM. This is the
first function the application can issue to RODM.</p>
        <p><b>Function Block Format</b></p>
        <p><i>Table 58. Function Block for the EKG_ConnectLong Function</i></p>
        <img src="tab22.jpg">
        <p>See “Function Parameter Descriptions” on page 452 for more information about the
parameters listed. See “Abstract Data Type Reference” on page 219 for more
information about the abstract data types listed.</p>
        <p><b>Examples</b></p>
        <p><i>Table 59. Example Names for the EKG_ConnectLong Function</i></p>
        <img src="tab23.jpg">
        <p><b>Summary</b></p>
        <p><i>Table 60. Summary of the EKG_ConnectLong Function</i></p>
        <img src="tab24.jpg">
        <p><b>Usage</b></p>
        <p>The User_appl_ID is used to determine the users access authority and to associate
registered ECBs with the appropriate user.</p>
        <p>If the system on which RODM is installed is protected by a system authorization
facility, the user can connect to RODM using a blank user ID. RODM obtains the user ID from the system authorization facility and uses it to determine the user's
access authority in RODM. If the system is not protected by a system authorization
facility, the user cannot connect to RODM using a blank user ID. </p>
        <p>When a user application issues an EKG_ConnectLong function request, RODM
creates a user object from the EKG_User system-defined class.</p>
        <p>An access block, as described in “Access Block” on page 309, must be passed. The
user's sign_on_token parameter in the access block is set by RODM. This
parameter must not be changed by the user application for subsequent calls to
RODM.</p>
        <p>A user can disconnect from RODM without purging the subscription notification
queue. Before notification queues owned by this user application ID can again be
posted, all ECB addresses associated with all notification queues for this user and
with subscription notifications must be reset for the new address space.</p>
        <p>All tasks in the address space from which the EKG_ConnectLong function was
issued can access RODM either by connecting to RODM with unique, RODM
authorized user IDs, or by using the sign_on_token. The sign_on_token is not valid
when the connecting TCB ends or the EKG_Disconnect function is performed.</p>
        <p><b>EKG_CreateClass - Create a Class
Purpose</b></p>
        <p>This function creates a new class as the child of a specified parent class in the
RODM data cache. RODM adds the new class ID entry to the MyClassChildren
linked-list field of the parent of the new class.</p>
        <p><b>Function Block Format</b></p>
        <p><i>Table 61. Function Block for the EKG_CreateClass Function</i></p>
        <img src="tab25.jpg">
        <p>See “Function Parameter Descriptions” on page 452 for more information about the
parameters listed. See “Abstract Data Type Reference” on page 219 for more
information about the abstract data types listed.</p>
        <p><b>Examples</b></p>
        <p><i>Table 62. Example Names for the EKG_CreateClass Function</i></p>
        <img src="tab26.jpg">
        <p><i>Table 62. Example Names for the EKG_CreateClass Function (continued)</i></p>
        <img src="tab27.jpg">
        <p><b>Summary</b></p>
        <p><i>Table 63. Summary of the EKG_CreateClass Function</i></p>
        <img src="tab28.jpg">
        <p><b>Usage</b></p>
        <p>Specify the class name and RODM returns the associated ID.</p>
        <p>Classes are created only with system-defined fields and those fields that are
inherited through the primary hierarchy. All additional fields must be added
explicitly by calls to RODM.</p>
        <p>Creating a class changes the value of the WhatIAm field of the parent of the class
if the parent did not have any class children.</p>
        <p><b>EKG_CreateField - Create a Field
Purpose</b></p>
        <p>This function creates a new field on a class in the RODM data cache.</p>
        <p><b>Function Block Format</b></p>
        <p><i>Table 64. Function Block for the EKG_CreateField Function</i></p>
        <img src="tab29.jpg">
        <p>See “Function Parameter Descriptions” on page 452 for more information about the
parameters listed. See “Abstract Data Type Reference” on page 219 for more
information about the abstract data types listed.</p>
        <p><b>Examples</b></p>
        <p><i>Table 65. Example Names for the EKG_CreateField Function</i></p>
        <img src="tab30.jpg">
        <p><b>Summary</b></p>
        <p><i>Table 66. Summary of the EKG_CreateField Function</i></p>
        <img src="tab31.jpg">
        <p><b>Usage</b></p>
        <p>The initial value for a field is the null value of the field's data type.</p>
        <p>When a field is created, RODM applies the following rules:</p>
        <p> If the field being added to a class is public and has the same name and fields
(that is, data type and subfield definitions) as a public field already defined in a
subclass, the field is defined in the specified class and the subclass defined field
is treated as a local value for that field (this affects what value is inherited below
the subclass). If the data type of the field in the subclass is different from the
new data type, the new definition is rejected.</p>
        <p>If the new field being added is a private field, no check is made for subclass
definitions.</p>
        <p>If a new field definition is for a public field and there is an existing private
definition in a subclass of the specified class, the new field definition is rejected.</p>
        <p>If the field already exists and has exactly the same data type and subfield
definitions as was requested, a warning return code is generated and a reason code
describing that condition is returned. The original field is left as previously
defined.</p>
        <p>If a subfield that is not valid is specified, RODM does not create that subfield.
However, RODM does create the field and all valid requested subfields. RODM
issues the warning return code 4 with reason code 100.</p>
        <p><b>EKG_CreateObject - Create an Object
Purpose</b></p>
        <p>This function creates a new object in the RODM data cache. RODM adds the new
object ID entry to the MyObjectChildren linked-list field of the parent of the new
object.</p>
        <p><b>Function Block Format</b></p>
        <p><i>Table 67. Function Block for the EKG_CreateObject Function</i></p>
        <img src="tab32.jpg">
        <p>See “Function Parameter Descriptions” on page 452 for more information about the
parameters listed. See “Abstract Data Type Reference” on page 219 for more
information about the abstract data types listed.</p>
        <p><b>Examples</b></p>
        <p><i>Table 68. Example Names for the EKG_CreateObject Function</i></p>
        <img src="tab33.jpg">
        <p><b>Summary</b></p>
        <p><i>Table 69. Summary of the EKG_CreateObject Function</i></p>
        <img src="tab34.jpg">
        <p><i>Table 69. Summary of the EKG_CreateObject Function (continued)</i></p>
        <img src="tab35.jpg">
        <p><b>Usage</b></p>
        <p>The Entity_access_info_ptr must point to an entity access block that specifies the
class which is the parent of the object being created. The Object_name_ptr of the
entity access block is optional. If the Object_name_ptr is specified, it must point to
a field of type ObjectName that contains the name of the requested new object.
Otherwise, RODM assigns the new object a name.</p>
        <p>If you are creating an object of the EKG_Method class or the
EKG_NotificationQueue class, the object name is required. Object names for these
classes are limited to 8 characters.</p>
        <p>The object name is not returned to the caller through this interface, but can be
accessed by querying the MyName field of the object. RODM assigns names in the
form EKGddddddd where ddddddd is a decimal number from 0000000 to 9999999. If
you specify the object name, do not specify an object name that begins with EKG.</p>
        <p>The Object_ID field in the entity access block is set by RODM when the object is
successfully created. The Method_Parms short_lived_parameters are passed to the
notification method on the MyObjectChildren field of the class and the notification
method, if one exists, is triggered.</p>
        <p>When a new object is created, it contains all of the public locally- defined and
inherited fields that appear on the class of the new object. The values in these
fields are initially the default values inherited from the class except for the
system-defined fields, which are set by RODM, and fields of type ObjectLink,
which are empty fields.</p>
        <p>All subfields, wherever they exist, begin existence on a new object with inherited
values except for the notify subfield. A Notify subfield starts out with the null
value.</p>
        <p>If the parent class does not have any object children when this object is created,
RODM updates the WhatIAm field of the class to indicate that the class now has
object children.</p>
        <p><b>EKG_CreateSubfield - Create a Subfield
Purpose</b></p>
        <p>This function creates one or more subfields for an existing field in an existing class
in the RODM data cache.</p>
        <p><b>Function Block Format</b></p>
        <p><i>Table 70. Function Block for the EKG_CreateSubfield Function</i></p>
        <img src="tab36.jpg">
        <p>See “Function Parameter Descriptions” on page 452 for more information about the
parameters listed. See “Abstract Data Type Reference” on page 219 for more
information about the abstract data types listed.</p>
        <p><b>Examples</b></p>
        <p><i>Table 71. Example Names for the EKG_CreateSubfield Function</i></p>
        <img src="tab37.jpg">
        <p><b>Summary</b></p>
        <p><i>Table 72. Summary of the EKG_CreateSubfield Function</i></p>
        <img src="tab38.jpg">
        <p><b>Usage</b></p>
        <p>Subfields can be created only on an existing field of a class. Subfields must be
created in the class in which the field was created.</p>
        <p>If a specified subfield already exists and other specified subfields do not exist, the
subfields that do not exist are created and a warning return code is generated.</p>
        <p><b>EKG_DeleteClass - Delete a Class
Purpose</b></p>
        <p>This function deletes an existing class from the RODM data cache. RODM removes
the value in the MyID field of the deleted class from the MyClassChildren
linked-list field of the parent of the deleted class.</p>
        <p><b>Function Block Format</b></p>
        <p><i>Table 73. Function Block for the EKG_DeleteClass Function</i></p>
        <img src="tab39.jpg">
        <p>See “Function Parameter Descriptions” on page 452 for more information about the
parameters listed. See “Abstract Data Type Reference” on page 219 for more
information about the abstract data types listed.</p>
        <p><b>Examples</b></p>
        <p><i>Table 74. Example Names for the EKG_DeleteClass Function</i></p>
        <img src="tab40.jpg">
        <p><b>Summary</b></p>
        <p><i>Table 75. Summary of the EKG_DeleteClass Function</i></p>
        <img src="tab41.jpg">
        <p><b>Usage</b></p>
        <p>You cannot delete a RODM system-defined class or a class that has children.</p>
        <p>Deleting a class will change the value of the WhatIAm field of the parent of the
class if the parent class no longer has any class children.</p>
        <p><b>EKG_DeleteField - Delete a Field
Purpose</b></p>
        <p>This function deletes a field from a class in the RODM data cache. The field is also
deleted from any classes and objects that inherit the field from this class.</p>
        <p><b>Function Block Format</b></p>
        <p><i>Table 76. Function Block for the EKG_DeleteField Function</i></p>
        <img src="tab42.jpg">
        <p>See “Function Parameter Descriptions” on page 452 for more information about the
parameters listed. See “Abstract Data Type Reference” on page 219 for more
information about the abstract data types listed.</p>
        <p><b>Examples</b></p>
        <p><i>Table 77. Example Names for the EKG_DeleteField Function</i></p>
        <img src="tab43.jpg">
        <p><b>Summary</b></p>
        <p><i>Table 78. Summary of the EKG_DeleteField Function</i></p>
        <img src="tab44.jpg">
        <p>Table 78. Summary of the EKG_DeleteField Function (continued)</p>
        <img src="tab45.jpg">
        <p><b>Usage</b></p>
        <p>Fields can be deleted only from classes; they cannot be deleted from objects.</p>
        <p>Deletion of a public field on a class removes the existence of that field from all
descendant classes.</p>
        <p>Before a public field can be deleted from a class, you must delete all objects
created from that class and from descendent classes of that class.</p>
        <p>Local values assigned to a field are discarded when that field is deleted.</p>
        <p>Private fields can be deleted at any time.</p>
        <p><b>EKG_DeleteNotifySubscription - Delete Notification
Subscription</b></p>
        <p>Purpose</p>
        <p>This function deletes one or more notification subscriptions from a field.</p>
        <p><b>Function Block Format</b></p>
        <p><i>Table 79. Function Block for the EKG_DeleteNotifySubscription Function</i></p>
        <img src="tab46.jpg">
        <p>See “Function Parameter Descriptions” on page 452 for more information about the
parameters listed. See “Abstract Data Type Reference” on page 219 for more
information about the abstract data types listed.</p>
        <p><b>Examples</b></p>
        <p><i>Table 80. Example Names for the EKG_DeleteNotifySubscription Function</i></p>
        <img src="tab47.jpg">
        <p><i>Table 80. Example Names for the EKG_DeleteNotifySubscription Function (continued)</i></p>
        <img src="tab48.jpg">
        <p><b>Summary</b></p>
        <p><i>Table 81. Summary of the EKG_DeleteNotifySubscription Function</i></p>
        <img src="tab49.jpg">
        <p><b>Usage</b></p>
        <p>Deleting a notification subscription does not delete the notification blocks that are
queued on the notification queue when the delete function is issued. The
notification queue object is not deleted.</p>
        <p>The notification subscription that is to be deleted is uniquely identified by four
fields: the User_appl_ID field, the Notification_queue field, the Notify_method
field, and the Long_lived_parm field. Using these four fields, the
EKG_DeleteNotifySubscription function deletes one or more notification
subscriptions based on the first of the following rules that applies:</p>
        <p>1. If the Notification_queue field is set to an asterisk followed by seven blanks
("* "), and the Notify_method and Long_lived_parm fields are set to
null values, all subscriptions associated with the specified User_appl_ID field
are deleted.</p>
        <p>2. If the Notification_queue field is set to an asterisk followed by seven blanks
("* "), all subscriptions associated with the specified User_appl_ID,
Notify_method, and Long_lived_parm fields are deleted.</p>
        <p>3. If the Notify_method field is set to the null value, RODM deletes the
notification subscriptions that meet the other criteria without considering the
value in the Notify_method field.</p>
        <p>4. If the Long_lived_parm field is set to the null value, RODM deletes the
notification subscriptions that meet the other criteria without considering the
value in the Long_lived_parm field.</p>
        <p>Specifying User_appl_ID as a null value does not have the same effect as
specifying null values for the other parameters. A Null User_appl_ID value is
interpreted the same here as for the EKG_AddNotifySubscription function; it</p>
        <p>requires RODM to supply a default value. The default is determined exactly as for
the EKG_AddNotifySubscription function (see “EKG_AddNotifySubscription - Add
Notification Subscription” on page 377).</p>
        <p>To specify a null Long_lived_parm, declare a pointer to the Long_lived_parm data
type with a value of zero.</p>
        <p><b>EKG_DeleteObject - Delete an Object
Purpose</b></p>
        <p>This function deletes an existing object from a specified class. RODM deletes the
object ID of the deleted object from the MyObjectChildren field of the parent class
of the deleted object.</p>
        <p><b>Function Block Format</b></p>
        <p><i>Table 82. Function Block for the EKG_DeleteObject Function</i></p>
        <img src="tab50.jpg">
        <p>See “Function Parameter Descriptions” on page 452 for more information about the
parameters listed. See “Abstract Data Type Reference” on page 219 for more
information about the abstract data types listed</p>
        <p><b>Examples</b></p>
        <p><i>Table 83. Example Names for the EKG_DeleteObject Function</i></p>
         <img src="tab51.jpg">
        <p><b>Summary</b></p>
        <p><i>Table 84. Summary of the EKG_DeleteObject Function</i></p>
        <img src="tab52.jpg">
    </body>

</html>